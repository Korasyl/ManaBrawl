diff --git a/scripts/visuals/crayola_rig.gd b/scripts/visuals/crayola_rig.gd
index b4277e98b0aa97b60dae0b95dc8787df9da747a7..bcbe8e25bf25d885aecf37d5e7e44e4127dcbfc2 100644
--- a/scripts/visuals/crayola_rig.gd
+++ b/scripts/visuals/crayola_rig.gd
@@ -301,74 +301,77 @@ func apply_weapon_state(pose: WeaponPoseData) -> void:
 		_blend_speed = 1.0 / pose.blend_in_time
 	else:
 		_blend_speed = 100.0  # Instant
 
 	# Weapon attachment
 	_attach_weapon(pose)
 
 	# Play enter animation
 	if pose.enter_animation != &"":
 		_play_oneshot(pose.enter_animation)
 
 ## Update arm aiming. Call every frame AFTER apply_weapon_state.
 ## aim_active: whether any arm should be code-driven this frame.
 ## aim_world_pos: mouse position in world coordinates.
 func update_arm_aim(aim_active: bool, aim_world_pos: Vector2) -> void:
 	if not aim_active:
 		# No aiming — smoothly return to rest pose.
 		# (Especially important for rigs without AnimationTree blend tracks.)
 		var reset_lerp := 0.20 * arm_lerp_speed / 18.0
 		_front_arm_angle = lerp_angle(_front_arm_angle, _front_arm_rest_rotation, reset_lerp)
 		_back_arm_angle = lerp_angle(_back_arm_angle, _back_arm_rest_rotation, reset_lerp)
 		front_arm_pivot.rotation = _front_arm_angle
 		back_arm_pivot.rotation = _back_arm_angle
 		front_forearm.rotation = lerp_angle(front_forearm.rotation, _front_forearm_rest_rotation, reset_lerp)
 		back_forearm.rotation = lerp_angle(back_forearm.rotation, _back_forearm_rest_rotation, reset_lerp)
+		_sync_weapon_rotation_to_hand()
 		return
 
 	var flags := _get_current_aim_flags()
 	# Fallback: if no pose/flags are configured, still aim the front arm for free-aim gameplay.
 	if flags == 0:
 		flags = 1
 
 	var lerp_factor := 0.15 * arm_lerp_speed / 18.0
 	var compensated_aim_world_pos := aim_world_pos + Vector2(0, aim_vertical_compensation)
 
 	# Front arm code aim
 	if flags & 1:
 		var target := _compute_aim_angle(front_arm_pivot.global_position, compensated_aim_world_pos)
 		_front_arm_angle = lerp_angle(_front_arm_angle, target, lerp_factor)
 		front_arm_pivot.rotation = _front_arm_angle
 		front_forearm.rotation = _front_arm_angle * 0.25
 
 	# Back arm code aim
 	if flags & 2:
 		var target := _compute_aim_angle(back_arm_pivot.global_position, compensated_aim_world_pos)
 		_back_arm_angle = lerp_angle(_back_arm_angle, target, lerp_factor)
 		back_arm_pivot.rotation = _back_arm_angle
 		back_forearm.rotation = _back_arm_angle * 0.25
 
+	_sync_weapon_rotation_to_hand()
+
 ## Advance the arm sequence to the next step (call on fire, cooldown start, etc.)
 func advance_sequence() -> void:
 	if _active_weapon_pose == null or not _active_weapon_pose.use_arm_sequence:
 		return
 	if _active_weapon_pose.sequence_steps.is_empty():
 		return
 
 	_sequence_index = (_sequence_index + 1) % _active_weapon_pose.sequence_steps.size()
 	var step := _active_weapon_pose.sequence_steps[_sequence_index]
 
 	# Update blend targets
 	_update_blend_targets(step.aim_arm_flags)
 
 	# Update arm animations
 	_apply_arm_animations_from_step(step)
 
 	# Swap weapon hand if needed
 	_update_weapon_hand(step.weapon_hand)
 
 	# Play transition animation
 	if step.transition_animation != &"":
 		_play_oneshot(step.transition_animation)
 
 	# Start auto-advance timer
 	_sequence_auto_timer = step.auto_advance_time
@@ -467,101 +470,130 @@ func _play_oneshot(anim_name: StringName) -> void:
 	if anim_tree:
 		# Trigger the one-shot layer
 		var oneshot = anim_tree.get("parameters/oneshot/request")
 		if oneshot != null:
 			anim_tree.set("parameters/oneshot_anim/animation", anim_name)
 			anim_tree.set("parameters/oneshot/request", AnimationNodeOneShot.ONE_SHOT_REQUEST_FIRE)
 	elif anim_player and anim_player.has_animation(anim_name):
 		anim_player.play(anim_name)
 
 func _on_animation_finished(anim_name: StringName) -> void:
 	transition_finished.emit(anim_name)
 
 # ---- Weapon Management ----
 
 func _attach_weapon(pose: WeaponPoseData) -> void:
 	_detach_weapon()
 
 	if pose.weapon_scene == null or pose.weapon_hand == "None":
 		return
 
 	_current_weapon_node = pose.weapon_scene.instantiate()
 	var parent := _get_weapon_parent(pose.weapon_hand)
 	if parent:
 		parent.add_child(_current_weapon_node)
 		_sync_weapon_visual_to_hand(pose.weapon_hand)
+		_sync_weapon_rotation_to_hand()
 
 func _detach_weapon() -> void:
 	if _current_weapon_node and is_instance_valid(_current_weapon_node):
 		_current_weapon_node.queue_free()
 		_current_weapon_node = null
 
 func _update_weapon_hand(hand: String) -> void:
 	if _current_weapon_node == null or not is_instance_valid(_current_weapon_node):
 		return
 
 	var current_parent := _current_weapon_node.get_parent()
 	var target_parent := _get_weapon_parent(hand)
 
 	if hand == "None":
 		_detach_weapon()
 		return
 
 	if current_parent != target_parent and target_parent:
 		current_parent.remove_child(_current_weapon_node)
 		target_parent.add_child(_current_weapon_node)
 	_sync_weapon_visual_to_hand(hand)
+	_sync_weapon_rotation_to_hand()
 
 func _get_weapon_parent(hand: String) -> Node2D:
 	match hand:
 		"Front":
 			if front_hand_weapon_anchor:
 				return front_hand_weapon_anchor
 			return front_forearm
 		"Back":
 			if back_hand_weapon_anchor:
 				return back_hand_weapon_anchor
 			return back_forearm
 		_:
 			return null
 
 func _sync_weapon_visual_to_hand(hand: String) -> void:
 	if _current_weapon_node == null or not is_instance_valid(_current_weapon_node):
 		return
 
 	_current_weapon_node.z_as_relative = true
 
 	match hand:
 		"Front":
 			if front_hand_sprite:
 				_current_weapon_node.z_index = front_hand_sprite.z_index
 		"Back":
 			if back_hand_sprite:
 				_current_weapon_node.z_index = back_hand_sprite.z_index
 		_:
 			pass
 
+func _get_current_weapon_hand() -> String:
+	if _active_weapon_pose == null:
+		return "None"
+	if _active_weapon_pose.use_arm_sequence and not _active_weapon_pose.sequence_steps.is_empty():
+		var step := _active_weapon_pose.sequence_steps[_sequence_index]
+		return step.weapon_hand
+	return _active_weapon_pose.weapon_hand
+
+func _sync_weapon_rotation_to_hand() -> void:
+	if _current_weapon_node == null or not is_instance_valid(_current_weapon_node):
+		return
+
+	var hand := _get_current_weapon_hand()
+	match hand:
+		"Front":
+			if front_hand_weapon_anchor:
+				_current_weapon_node.global_rotation = front_hand_weapon_anchor.global_rotation
+			elif front_forearm:
+				_current_weapon_node.global_rotation = front_forearm.global_rotation
+		"Back":
+			if back_hand_weapon_anchor:
+				_current_weapon_node.global_rotation = back_hand_weapon_anchor.global_rotation
+			elif back_forearm:
+				_current_weapon_node.global_rotation = back_forearm.global_rotation
+		_:
+			pass
+
 # ---- Utility ----
 
 func _apply_pixel_settings(root: Node) -> void:
 	for child in root.get_children():
 		if child is Sprite2D:
 			child.centered = false
 			child.texture_filter = CanvasItem.TEXTURE_FILTER_NEAREST
 		_apply_pixel_settings(child)
 
 ## Resolve an animation name, falling back to FALLBACK_ANIM if it doesn't exist.
 func _resolve_animation(anim: StringName) -> StringName:
 	# Check AnimationPlayer first
 	if anim_player and anim_player.has_animation(anim):
 		return anim
 
 	# Check if AnimationTree state machine has this state
 	if anim_tree:
 		var playback = anim_tree.get("parameters/body_state/playback")
 		if playback is AnimationNodeStateMachinePlayback:
 			# Can't easily check states, trust the AnimationPlayer check above
 			pass
 
 	# Animation missing — warn and fallback
 	_warn_missing_animation(anim)
 	return FALLBACK_ANIM
